using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using Asp.Versioning;
using Asp.Versioning.Builder;
using Hydroponics.Data.DataTransferObjects;
using Microsoft.AspNetCore.Mvc;
using Microsoft.IdentityModel.Tokens;

namespace Hydroponics.Endpoints;

internal static class AccessEndpoints
{
    private static readonly string Collection = "access";

    public static IResult Login(UserDto login, [FromServices] IConfiguration config)
    {
        if (login.UserName == "test-user" && login.Password == "P@ssword")
        {
            string? issuer = config["Jwt:Issuer"];
            string? audience = config["Jwt:Audience"];
            SymmetricSecurityKey securityKey = new(Encoding.UTF8.GetBytes(config["Jwt:Key"] ?? ""));
            SigningCredentials credentials = new(securityKey, SecurityAlgorithms.HmacSha256);

            // TODO: just for testing
            Console.WriteLine($"The algorithm is {credentials.Algorithm}");

            // Now its ime to define the jwt token which will be responsible of creating our tokens
            JwtSecurityTokenHandler jwtTokenHandler = new();

            // We get our secret from the appsettings
            byte[] key = Encoding.ASCII.GetBytes(config["Jwt:Key"] ?? "");

            // we define our token descriptor
            // We need to utilise claims which are properties in our token which gives information about the token
            // which belong to the specific user who it belongs to
            // so it could contain their id, name, email the good part is that these information
            // are generated by our server and identity framework which is valid and trusted
            SecurityTokenDescriptor tokenDescriptor = new()
            {
                Subject = new ClaimsIdentity(new[]
              {
                new Claim("Id", "1"),
                new Claim(JwtRegisteredClaimNames.Sub, login.UserName),
                new Claim(JwtRegisteredClaimNames.Email, login.UserName),
                // the JTI is used for our refresh token which we will be convering in the next video
                new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
            }),
                // the life span of the token needs to be shorter and utilise refresh token to keep the user signedin
                // but since this is a demo app we can extend it to fit our current need
                Expires = DateTime.UtcNow.AddHours(6),
                Audience = audience,
                Issuer = issuer,
                // here we are adding the encryption alogorithim information which will be used to decrypt our token
                SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha512Signature)
            };

            SecurityToken securityToken = jwtTokenHandler.CreateToken(tokenDescriptor);

            string token = jwtTokenHandler.WriteToken(securityToken);

            return Results.Ok(new { token });
        }
        else
        {
            return Results.Unauthorized();
        }
    }

    public static void MapAccessEndpoints(this WebApplication app, string basePath, ApiVersionSet versionSet,
                                      ApiVersion currentVersion)
    {
        app.MapPost($"{basePath}/{Collection}", Login)
          .AllowAnonymous()
          .RequireRateLimiting("sliding")
          .Produces<string>(StatusCodes.Status200OK)
          .ProducesProblem(StatusCodes.Status401Unauthorized)
          .WithName("PostAccessLogin")
          .WithTags(new[] { Collection })
          .WithOpenApi()
          .WithApiVersionSet(versionSet)
          .HasApiVersion(currentVersion);
    }
}